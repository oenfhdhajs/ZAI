1. WalletConnect Integration
Purpose
This component allows users to connect their cryptocurrency wallets (e.g., MetaMask, Trust Wallet) to the ZAI World wallet app, enabling them to manage ZAI tokens and other assets.
Code
javascript
// frontend/src/components/WalletConnect.js
import React, { useState } from 'react';
import WalletConnectProvider from '@walletconnect/web3-provider';
import Web3 from 'web3';

const WalletConnect = ({ onConnect }) => {
  const [account, setAccount] = useState(null);
  const [web3, setWeb3] = useState(null);

  const connectWallet = async () => {
    try {
      const provider = new WalletConnectProvider({
        infuraId: 'YOUR_INFURA_KEY', // Replace with your Infura project ID
        chainId: 1, // Ethereum Mainnet; adjust for ZAI’s blockchain
      });

      await provider.enable();
      const web3Instance = new Web3(provider);
      const accounts = await web3Instance.eth.getAccounts();
      setAccount(accounts[0]);
      setWeb3(web3Instance);
      onConnect(accounts[0], web3Instance);

      provider.on('disconnect', () => {
        setAccount(null);
        setWeb3(null);
      });
    } catch (error) {
      console.error('WalletConnect failed:', error);
    }
  };

  return (
    <div>
      {account ? (
        <p>Connected: {account.slice(0, 6)}...{account.slice(-4)}</p>
      ) : (
        <button onClick={connectWallet}>Connect Wallet</button>
      )}
    </div>
  );
};

export default WalletConnect;
Explanation
Functionality: When the user clicks "Connect Wallet," the WalletConnect provider generates a QR code or deep link. Scanning this with a wallet app (e.g., MetaMask) connects the wallet to the ZAI app.
State Management: Tracks the connected account and Web3 instance using React’s useState.
Event Handling: Listens for disconnection events to reset the state if the user disconnects their wallet.
Integration: Passes the account and Web3 instance to the parent component via the onConnect callback for use in other parts of the app.
2. Bubble Web UI
Purpose
Displays the user’s assets in a visually engaging, circular "bubble web" layout, where each bubble represents an asset, sized by its value.
Code
javascript
// frontend/src/components/BubbleWeb.js
import React from 'react';
import { Stage, Layer, Circle } from 'react-konva';

const BubbleWeb = ({ assets }) => {
  const centerX = 400;
  const centerY = 400;

  return (
    <Stage width={800} height={800}>
      <Layer>
        {assets.map((asset, index) => {
          const angle = (index / assets.length) * 2 * Math.PI;
          const x = centerX + 200 * Math.cos(angle);
          const y = centerY + 200 * Math.sin(angle);
          const size = asset.value / 10; // Scale size based on value
          return <Circle key={index} x={x} y={y} radius={size} fill={asset.color} />;
        })}
        {/* Central Avatar */}
        <Circle x={centerX} y={centerY} radius={50} fill="purple" />
      </Layer>
    </Stage>
  );
};

export default BubbleWeb;
Explanation
Library: Uses react-konva to render a canvas with circles (bubbles).
Layout: Assets are positioned in a circle around a central point (the "avatar") using trigonometry (cos and sin).
Visualization: Each bubble’s size reflects the asset’s value, and its color is customizable.
Central Avatar: Represents the AI agent or user identity, fixed at the center.
3. Chat Box for AI Interaction
Purpose
Provides a simple interface for users to send messages or commands to the AI agent, such as "Send 10 ZAI" or "Swap ETH for ZAI."
Code
javascript
// frontend/src/components/ChatBox.js
import React, { useState } from 'react';

const ChatBox = ({ onCommand }) => {
  const [message, setMessage] = useState('');

  const sendMessage = () => {
    onCommand(message);
    setMessage(''); // Clear input after sending
  };

  return (
    <div>
      <input
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        placeholder="Talk to your ZAI agent..."
      />
      <button onClick={sendMessage}>Send</button>
    </div>
  );
};

export default ChatBox;
Explanation
UI: A text input and a "Send" button allow users to type and submit messages.
State: The message state tracks the current input value.
Action: The onCommand callback sends the message to the parent component for processing (e.g., forwarding to the backend).
4. AI-Powered Agent (Backend)
Purpose
Processes user commands using the DeepSeek API, interprets their intent, and returns structured responses to trigger actions like trading or staking.
Code
javascript
// backend/deepseek.js
const axios = require('axios');
require('dotenv').config();

const deepseekApiKey = process.env.DEEPSEEK_API_KEY;
const deepseekEndpoint = 'https://api.deepseek.com/v1/chat';

async function processCommand(userInput, userContext) {
  const prompt = `
    You are an AI agent for the ZAI World wallet. The user says: "${userInput}".
    User context: ${JSON.stringify(userContext)}.
    Interpret the intent and suggest actions (e.g., buy, sell, stake, swap, invest).
    Return a JSON response with:
    - intent: the user's goal
    - actions: array of steps to execute
    - reply: natural language response to the user
  `;

  const response = await axios.post(deepseekEndpoint, {
    model: 'deepseek-chat',
    messages: [{ role: 'user', content: prompt }],
    api_key: deepseekApiKey,
  });

  return response.data.choices[0].message.content;
}

module.exports = { processCommand };
Explanation
API Call: Sends a prompt to DeepSeek with the user’s input and context (e.g., wallet balance).
Prompt Design: Instructs DeepSeek to interpret intent and return a JSON object with intent, actions, and reply.
Response: The returned JSON is parsed by the backend to execute actions and reply to the user.
Environment: Uses a .env file to securely store the DeepSeek API key.
5. Backend Server with WalletConnect and Token Movement
Purpose
Handles API requests from the frontend, processes AI commands, and executes blockchain transactions like sending tokens or staking.
Code
javascript
// backend/server.js
const express = require('express');
const { processCommand } = require('./deepseek.js');
const ethers = require('ethers');
require('dotenv').config();

const app = express();
app.use(express.json());

const provider = new ethers.JsonRpcProvider('https://mainnet.infura.io/v3/YOUR_INFURA_KEY');
const zaiTokenAddress = 'YOUR_ZAI_TOKEN_ADDRESS'; // Deployed ZAIToken.sol address
const stakingAddress = 'YOUR_STAKING_ADDRESS';   // Deployed ZAIStaking.sol address
const zaiTokenABI = [ /* ABI from ZAIToken.sol */ ];
const stakingABI = [ /* ABI from ZAIStaking.sol */ ];

// Mock user context (replace with a database in production)
const userContext = {
  '0x123...': { address: '0x123...', balance: { ZAI: 100, ETH: 2 }, preferences: {} },
};

async function sendTokens(fromAddress, toAddress, amount, web3) {
  const contract = new web3.eth.Contract(zaiTokenABI, zaiTokenAddress);
  const tx = await contract.methods.transfer(toAddress, ethers.parseUnits(amount.toString(), 18))
    .send({ from: fromAddress });
  return { txHash: tx.transactionHash };
}

async function swapTokens(fromAddress, fromToken, toToken, amount, web3) {
  // Placeholder: Integrate with a DEX like Uniswap
  console.log(`Swapping ${amount} ${fromToken} for ${toToken}`);
  return { txHash: '0xmockswap' };
}

async function stakeTokens(fromAddress, amount, web3) {
  const contract = new web3.eth.Contract(stakingABI, stakingAddress);
  const tx = await contract.methods.stake(ethers.parseUnits(amount.toString(), 18))
    .send({ from: fromAddress });
  return { txHash: tx.transactionHash };
}

app.post('/api/chat', async (req, res) => {
  const { userId, message, web3Provider } = req.body; // web3Provider from WalletConnect
  const context = userContext[userId] || {};
  const web3 = new ethers.Web3(web3Provider);

  try {
    const aiResponse = await processCommand(message, context);
    const parsedResponse = JSON.parse(aiResponse);

    const results = [];
    for (const action of parsedResponse.actions) {
      if (action.type === 'send') {
        const result = await sendTokens(userId, action.to, action.amount, web3);
        results.push(result);
      } else if (action.type === 'swap') {
        const result = await swapTokens(userId, 'ZAI', action.toToken, action.amount, web3);
        results.push(result);
      } else if (action.type === 'stake') {
        const result = await stakeTokens(userId, action.amount, web3);
        results.push(result);
      }
    }

    res.json({ reply: parsedResponse.reply, results });
  } catch (error) {
    res.status(500).json({ error: 'Failed to process command: ' + error.message });
  }
});

app.listen(5000, () => console.log('Server running on port 5000'));
Explanation
Server Setup: Uses Express.js to handle HTTP requests.
Blockchain Interaction: Integrates with Ethereum via ethers.js and the user’s WalletConnect provider.
Functions: Implements sendTokens, swapTokens, and stakeTokens to execute transactions based on AI actions.
API Endpoint: The /api/chat route processes chat messages, calls DeepSeek, and executes the resulting actions.
Error Handling: Returns errors to the frontend if something fails.
6. ZAI Token and Staking Contracts
Purpose
Defines the ZAI token (an ERC-20 token) and a staking contract for users to lock tokens and earn rewards.
Code
ZAIToken.sol
solidity
// contracts/ZAIToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";

contract ZAIToken is ERC20, AccessControl {
  bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
  uint256 public constant INITIAL_SUPPLY = 20_000_000 * 10**18;

  constructor() ERC20("ZAI Token", "ZAI") {
    _mint(msg.sender, INITIAL_SUPPLY);
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    _setupRole(MINTER_ROLE, msg.sender);
  }

  function mint(address to, uint256 amount) public {
    require(hasRole(MINTER_ROLE, msg.sender), "Caller is not a minter");
    _mint(to, amount);
  }
}
ZAIStaking.sol
solidity
// contracts/ZAIStaking.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ZAIStaking {
  IERC20 public zaiToken;
  mapping(address => uint256) public staked;

  constructor(address _zaiToken) {
    zaiToken = IERC20(_zaiToken);
  }

  function stake(uint256 amount) external {
    zaiToken.transferFrom(msg.sender, address(this), amount);
    staked[msg.sender] += amount;
  }

  function withdraw(uint256 amount) external {
    require(staked[msg.sender] >= amount, "Insufficient stake");
    staked[msg.sender] -= amount;
    zaiToken.transfer(msg.sender, amount);
  }
}
Explanation
ZAIToken.sol: An ERC-20 token with a 20 million initial supply and a mint function restricted to minters.
ZAIStaking.sol: A basic staking contract where users can deposit (stake) and withdraw ZAI tokens.
Dependencies: Uses OpenZeppelin contracts for security and standardization.
7. Main Application Component
Purpose
Ties together all frontend components (WalletConnect, BubbleWeb, ChatBox) into a single app interface.
Code
javascript
// frontend/src/App.js
import React, { useState } from 'react';
import BubbleWeb from './components/BubbleWeb';
import ChatBox from './components/ChatBox';
import WalletConnect from './components/WalletConnect';
import './App.css';

const initialAssets = [
  { name: 'ZAI', value: 100, color: 'blue' },
  { name: 'ETH', value: 2, color: 'silver' },
];

function App() {
  const [assets, setAssets] = useState(initialAssets);
  const [chatReply, setChatReply] = useState('');
  const [wallet, setWallet] = useState({ account: null, web3: null });

  const handleConnect = (account, web3) => {
    setWallet({ account, web3 });
  };

  const handleCommand = async (message) => {
    if (!wallet.account) {
      setChatReply('Please connect your wallet first!');
      return;
    }
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId: wallet.account, message, web3Provider: wallet.web3.currentProvider }),
    }).then(res => res.json());
    
    setChatReply(response.reply);
    if (response.results.length) {
      setAssets(prev => prev.map(a => ({ ...a }))); // Mock update; replace with real data
    }
  };

  return (
    <div className="App">
      <h1>ZAI World Wallet</h1>
      <WalletConnect onConnect={handleConnect} />
      <BubbleWeb assets={assets} />
      <ChatBox onCommand={handleCommand} />
      {chatReply && <p>AI: {chatReply}</p>}
    </div>
  );
}

export default App;
Explanation
State: Manages assets, chat replies, and wallet connection details.
Integration: Connects the wallet, displays assets in the bubble web, and handles chat commands.
Backend Communication: Sends chat messages to the backend and updates the UI with the AI’s response.
8. CSS for Styling
Purpose
Provides basic styling to make the app visually appealing and user-friendly.
Code
css
/* frontend/src/App.css */
.App {
  text-align: center;
  font-family: Arial, sans-serif;
}
Explanation
Styling: Centers content and sets a clean, readable font. You can expand this with more styles as needed.
9. README.md
Purpose
Guides developers on how to set up and run the ZAI World wallet app.
Code
markdown
# ZAI World Wallet

A next-gen wallet with WalletConnect, bubble UI, and a DeepSeek-powered AI agent.

## Setup

1. **Backend**:
   - `cd backend`
   - `npm install express axios dotenv ethers`
   - Add `.env` with `DEEPSEEK_API_KEY`, `INFURA_KEY`, `PRIVATE_KEY`
   - `node server.js`

2. **Frontend**:
   - `cd frontend`
   - `npm install react react-konva axios @walletconnect/web3-provider web3`
   - `npm start`

3. **Contracts**:
   - Deploy `ZAIToken.sol` and `ZAIStaking.sol` using Hardhat/Truffle.
   - Update `server.js` with contract addresses.

## Usage

- Connect your wallet via WalletConnect (scan QR with MetaMask, etc.).
- Chat with the AI: "Send 10 ZAI to 0x456..." or "Stake 50 ZAI."
- Watch the bubble UI update with your actions.

## Notes

- Built with DeepSeek for AI; adjust prompts for other models.
- WalletConnect enables token movement between app, user account, and ZAI ecosystem.
Explanation
Instructions: Covers installation, configuration, and usage steps.
Dependencies: Lists required npm packages for both frontend and backend.
Customization: Notes where to update contract addresses and API keys.
This completes the fully developed ZAI World wallet app, presented one component at a time. Each section is modular, allowing you to tweak or expand it as needed. Let me know if you’d like further refinements!
